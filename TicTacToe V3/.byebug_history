c
q
@grids
@grids = Array.new(m) { Array.new(m, '_') }
m
c
@grids
s
@grids
n
c
n
@grids
n
Array.new(m)
m
@grids
Array.new(m) { Array.new(m, '_') }
Array.new(m) { Array.new(m, '_' }
@grids
m
n
q
n
q
a.player
a
a = Board.new(duped_rows)
Board.new(duped_rows)
duped_rows
n
c
q
n
display !child.lose_node?(mark)
display child.prev_move_pos
child.prev_move_pos
s
n
s
q
get_position(legal_positions, game, mark)
display !child.lose_node?(mark)
n
s
q
pos
n
display child.lose_node?(mark)
n
display child.win_node?(mark)
s
n
s
@current_player.mark
current_player.mark
c
pos
c
pos
c
n
q
c
cc
c
cc
c
n
c
q
value
children.last.board
children.last
children
n
self
n
pos
@grids[pos[0]][pos[1]] = mark
mark
@grids[pos[0]][pos[1]]
@grids
pos
c
pos
mark
n
display child.lose_node?(mark)
s
n
display child.win_node?(mark)
q
c
display child.win_node?(mark)
n
pos
c
n
display child.win_node?(mark)
q
pos
n
display child.win_node?(mark)
child.win_node?(mark)
child.prev_move_pos
s
child.prev_move_pos
n
q
pos
q
pos.board
pos
c
q
n
pos
oos
return child.prev_move_pos
s
c
q
n
s
display child
q
pos
c
n
child.prev_move_pos
child
s
q
all_possible_moves
child
child.prev_move_pos
q
child.prev_move_pos
pos
pos.prev_move_pos
D@prev_move_pos
prev_move_pos
pos
q
c
q
board.dup
c
q
c
q
value
c
q
c
children.last.value
value == :x ? :o : :x
value
n
value
n
value
valuje
n
value
c
cc
c
cc
c
q
@grids
@grids[pos[0]][pos[1]] = mark
self.mark
mark
s
n
self.mar
c
self.mark
mark
s
n
q
c
board
baord
value
cval
c
nc
n
value
n
board
n
board
n
board
c
q
board
n
board
n
value
n
board
n
board
n
board
q
cq
c
value
board
n
value
n
value
board
n
board
n
board
n
board
q
children.last
children.last.board[[i,j]] = value
value
children.last
value
n
value
children.last
children.last.board[[i,j]] = value
children.last
children
c
q
[i,j]
children.last.board[[i,j]] = value
children.last
children.last.board[[i,j]] = value
children.last
children.last.board[[i,j]] = value
children.last.board
children.last
children
n
q
children
c
